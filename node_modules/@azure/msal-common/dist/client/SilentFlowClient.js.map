{"version":3,"file":"SilentFlowClient.js","sources":["../../src/client/SilentFlowClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { BaseClient } from \"./BaseClient\";\nimport { ClientConfiguration } from \"../config/ClientConfiguration\";\nimport { CommonSilentFlowRequest } from \"../request/CommonSilentFlowRequest\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\nimport { AuthToken } from \"../account/AuthToken\";\nimport { TimeUtils } from \"../utils/TimeUtils\";\nimport { RefreshTokenClient } from \"./RefreshTokenClient\";\nimport { ClientAuthError, ClientAuthErrorMessage } from \"../error/ClientAuthError\";\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\nimport { ResponseHandler } from \"../response/ResponseHandler\";\nimport { CacheRecord } from \"../cache/entities/CacheRecord\";\nimport { CacheOutcome } from \"../utils/Constants\";\n\nexport class SilentFlowClient extends BaseClient {\n\n    constructor(configuration: ClientConfiguration) {\n        super(configuration);\n    }\n\n    /**\n     * Retrieves a token from cache if it is still valid, or uses the cached refresh token to renew\n     * the given token and returns the renewed token\n     * @param request\n     */\n    async acquireToken(request: CommonSilentFlowRequest): Promise<AuthenticationResult> {\n        try {\n            return await this.acquireCachedToken(request);\n        } catch (e) {\n            if (e instanceof ClientAuthError && e.errorCode === ClientAuthErrorMessage.tokenRefreshRequired.code) {\n                const refreshTokenClient = new RefreshTokenClient(this.config);\n                return refreshTokenClient.acquireTokenByRefreshToken(request);\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    /**\n     * Retrieves token from cache or throws an error if it must be refreshed.\n     * @param request\n     */\n    async acquireCachedToken(request: CommonSilentFlowRequest): Promise<AuthenticationResult> {\n        // Cannot renew token if no request object is given.\n        if (!request) {\n            throw ClientConfigurationError.createEmptyTokenRequestError();\n        }\n\n        if (request.forceRefresh) {\n            // Must refresh due to present force_refresh flag.\n            this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.FORCE_REFRESH);\n            this.logger.info(\"SilentFlowClient:acquireCachedToken - Skipping cache because forceRefresh is true.\");\n            throw ClientAuthError.createRefreshRequiredError();\n        }\n\n        // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\n        if (!request.account) {\n            throw ClientAuthError.createNoAccountInSilentRequestError();\n        }\n\n        const environment = request.authority || this.authority.getPreferredCache();\n\n        const cacheRecord = this.cacheManager.readCacheRecord(request.account, this.config.authOptions.clientId, request, environment);\n        \n        if (!cacheRecord.accessToken) {\n            // Must refresh due to non-existent access_token.\n            this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);\n            this.logger.info(\"SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.\");\n            throw ClientAuthError.createRefreshRequiredError();\n        } else if (\n            TimeUtils.wasClockTurnedBack(cacheRecord.accessToken.cachedAt) ||\n            TimeUtils.isTokenExpired(cacheRecord.accessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)\n        ) {\n            // Must refresh due to expired access_token.\n            this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);\n            this.logger.info(`SilentFlowClient:acquireCachedToken - Cached access token is expired or will expire within ${this.config.systemOptions.tokenRenewalOffsetSeconds} seconds.`);\n            throw ClientAuthError.createRefreshRequiredError();\n        } else if (cacheRecord.accessToken.refreshOn && TimeUtils.isTokenExpired(cacheRecord.accessToken.refreshOn, 0)) {\n            // Must refresh due to the refresh_in value.\n            this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.REFRESH_CACHED_ACCESS_TOKEN);\n            this.logger.info(\"SilentFlowClient:acquireCachedToken - Cached access token's refreshOn property has been exceeded'.\");\n            throw ClientAuthError.createRefreshRequiredError();\n        }\n\n        if (this.config.serverTelemetryManager) {\n            this.config.serverTelemetryManager.incrementCacheHits();\n        }\n\n        return await this.generateResultFromCacheRecord(cacheRecord, request);\n    }\n\n    /**\n     * Helper function to build response object from the CacheRecord\n     * @param cacheRecord\n     */\n    private async generateResultFromCacheRecord(cacheRecord: CacheRecord, request: CommonSilentFlowRequest): Promise<AuthenticationResult> {\n        let idTokenObj: AuthToken | undefined;\n        if (cacheRecord.idToken) {\n            idTokenObj = new AuthToken(cacheRecord.idToken.secret, this.config.cryptoInterface);\n        }\n        return await ResponseHandler.generateAuthenticationResult(\n            this.cryptoUtils,\n            this.authority,\n            cacheRecord,\n            true,\n            request,\n            idTokenObj\n        );\n    }\n}\n"],"names":[],"mappings":"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"}